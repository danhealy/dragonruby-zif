<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Zif: A Drop-in Framework for DragonRuby GTK - dragonruby-zif</title>
<meta name="description" content="Zif: A Drop-in Framework for DragonRuby GTK">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="dragonruby-zif">
<meta property="og:title" content="Zif: A Drop-in Framework for DragonRuby GTK">
<meta property="og:url" content="/">


  <meta property="og:description" content="Zif: A Drop-in Framework for DragonRuby GTK">












<link rel="canonical" href="/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="dragonruby-zif Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          dragonruby-zif
          
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Zif: A Drop-in Framework for DragonRuby GTK">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Zif: A Drop-in Framework for DragonRuby GTK
</h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#example-app">Example App</a><ul><li><a href="#running-the-example-app">Running the Example App:</a></li></ul></li><li><a href="#installation-in-your-app">Installation in your app:</a></li><li><a href="#basic-features">Basic Features</a><ul><li><a href="#zifsprite">Zif::Sprite</a></li><li><a href="#zifcompoundsprite">Zif::CompoundSprite</a></li><li><a href="#zifrendertarget">Zif::RenderTarget</a></li><li><a href="#zifgame">Zif::Game</a></li><li><a href="#zifscene">Zif::Scene</a></li></ul></li><li><a href="#zifactions-aka-tweening-easing">Zif::Actions (aka tweening, easing)</a><ul><li><a href="#zifactionsaction--zifactionsactionable">Zif::Actions::Action &amp; Zif::Actions::Actionable</a></li><li><a href="#zifactionssequence">Zif::Actions::Sequence</a></li><li><a href="#zifactionsanimatable">Zif::Actions::Animatable</a></li></ul></li><li><a href="#ziflayers">Zif::Layers</a><ul><li><a href="#ziflayerslayergroup">Zif::Layers::LayerGroup</a></li><li><a href="#ziflayerssimplelayer">Zif::Layers::SimpleLayer</a></li><li><a href="#ziflayersactivelayer">Zif::Layers::ActiveLayer</a></li><li><a href="#deciding-between-ziflayerssimplelayer--ziflayersactivelayer">Deciding between Zif::Layers::SimpleLayer &amp; Zif::Layers::ActiveLayer</a></li><li><a href="#ziflayerstileable">Zif::Layers::Tileable</a></li><li><a href="#ziflayersbitmaskable">Zif::Layers::Bitmaskable</a></li><li><a href="#ziflayerscamera">Zif::Layers::Camera</a></li></ul></li><li><a href="#zifui">Zif::UI</a><ul><li><a href="#zifuilabel">Zif::UI::Label</a></li><li><a href="#zifuiinput">Zif::UI::Input</a></li><li><a href="#zifuitwostagebutton">Zif::UI::TwoStageButton</a></li><li><a href="#zifuininepanel">Zif::UI::NinePanel</a></li></ul></li><li><a href="#zifservices--zifservicesservicegroup">Zif::Services &amp; Zif::Services::ServiceGroup</a><ul><li><a href="#zifservicesactionservice">Zif::Services::ActionService</a></li><li><a href="#zifservicesinputservice">Zif::Services::InputService</a></li><li><a href="#zifservicesspriteregistry">Zif::Services::SpriteRegistry</a></li><li><a href="#zifservicesticktraceservice--ziftraceable">Zif::Services::TickTraceService &amp; Zif::Traceable</a></li></ul></li><li><a href="#dependencies">Dependencies</a></li><li><a href="#testing">Testing</a></li><li><a href="#linting">Linting</a></li></ul>

            </nav>
          </aside>
        
        <p>Zif is a collection of features commonly required in 2D games.  The name is a reference to <a href="https://console5.com/wiki/Improving_NES-001_Reliability">Zero Insertion Force connectors used on the original Nintendo</a> - You can drop it in your project and it should just work.  Everything is namespaced to <code class="language-plaintext highlighter-rouge">Zif</code> so any existing classes or namespaces you have should be preserved.</p>

<p>This readme contains a basic overview of the functionality.  If you are looking for more detail, please check the class API level documentation - e.g. <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Sprite.html"><code class="language-plaintext highlighter-rouge">Zif::Sprite</code></a>.</p>

<p><strong>The best version of this README is available here:</strong>
<a href="https://danhealy.github.io/dragonruby-zif/">https://danhealy.github.io/dragonruby-zif/</a></p>

<p>Full API documentation is available at <a href="https://danhealy.github.io/dragonruby-zif/docs/">https://danhealy.github.io/dragonruby-zif/docs/</a></p>

<h2 id="example-app">Example App</h2>
<p>This repo is an example app showcasing the major features - the <code class="language-plaintext highlighter-rouge">Zif</code> library itself is entirely contained within the <code class="language-plaintext highlighter-rouge">app/lib</code> directory.</p>

<p><img src="https://github.com/danhealy/docs/blob/main/dragonruby-zif/ui_sample.gif?raw=true" alt="" /></p>

<h3 id="running-the-example-app">Running the Example App:</h3>
<ol>
  <li>Create a fresh copy of DragonRuby GTK - you can call this folder <code class="language-plaintext highlighter-rouge">dragonruby-zif-testbed</code> and it should contain the <code class="language-plaintext highlighter-rouge">dragonruby</code> executable.</li>
  <li>Change directory in your terminal to <code class="language-plaintext highlighter-rouge">dragonruby-zif-testbed</code></li>
  <li>Clone this entire <code class="language-plaintext highlighter-rouge">dragonruby-zif</code> repo inside the <code class="language-plaintext highlighter-rouge">dragonruby-zif-testbed</code> directory - <code class="language-plaintext highlighter-rouge">git clone https://github.com/danhealy/dragonruby-zif.git</code>.</li>
  <li>Run using <code class="language-plaintext highlighter-rouge">./dragonruby dragonruby-zif/</code></li>
</ol>

<h2 id="installation-in-your-app">Installation in your app:</h2>

<p>App dependencies in DRGTK currently have to be managed manually, by copying the source into your project.</p>

<ol>
  <li>Download a copy of Zif somewhere: <code class="language-plaintext highlighter-rouge">git clone https://github.com/danhealy/dragonruby-zif.git</code>.</li>
  <li>Create a <code class="language-plaintext highlighter-rouge">lib</code> directory inside your project’s <code class="language-plaintext highlighter-rouge">app</code> directory, and then copy Zif’s <code class="language-plaintext highlighter-rouge">app/lib/zif</code> directory into it.</li>
  <li>In your <code class="language-plaintext highlighter-rouge">main.rb</code>, require the parts of Zif you need.  To require everything:</li>
</ol>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Require all of the Zif library:</span>
<span class="nb">require</span> <span class="s1">'app/lib/zif/require.rb'</span>

<span class="k">def</span> <span class="nf">tick</span>
  <span class="c1"># ....</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you only want to require some parts, please see the <code class="language-plaintext highlighter-rouge">require.rb</code> file for more information.</p>

<h1 id="motivation">Motivation</h1>

<p>DragonRuby GTK provides the basic functionality you need to program a game.  It has the concept of the <code class="language-plaintext highlighter-rouge">tick</code> loop, lets you render sprites to the screen by sending basic value objects to <code class="language-plaintext highlighter-rouge">outputs</code>, and so on.</p>

<p>There is a set of data and behavior that all sprites in your game share - they all have a position, they all have width and height, they all reference a path to some image, etc.  Maybe you are working on a puzzle game - your puzzle pieces are sprites, but they share some additional behavior and data - which piece it is, how pieces can move.  Why not leverage this similarity by formalizing the shared concepts in your game?  You may want to consider using object-oriented design to encapsulate the distinct concepts in your code.  After all, the Ruby programming language has a strong focus on supporting object-oriented programming techniques.</p>

<p>Zif aims to provide a framework for the shared concepts you might have in any game, as they relate to using the DragonRuby GTK.  The foundation of Zif is the <code class="language-plaintext highlighter-rouge">Zif::Sprite</code> class, which defines the attributes a Sprite needs to have to work with DRGTK, and builds on that to provide some functionality not given to you directly by DRGTK.  For example, maybe you want know the center point of your sprite?  If you are only using the value objects expected by DRGTK, you defined it using <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> coordinates with some <code class="language-plaintext highlighter-rouge">width</code> and <code class="language-plaintext highlighter-rouge">height</code>, and that’s all it knows.  If you define the same sprite using <code class="language-plaintext highlighter-rouge">Zif::Sprite</code>, you can use <code class="language-plaintext highlighter-rouge">Zif::Sprite#center</code>.  This becomes more powerful as you build upon it.  You could make a <code class="language-plaintext highlighter-rouge">PuzzlePiece</code> class which inherits from <code class="language-plaintext highlighter-rouge">Zif::Sprite</code>, and now it can also find it’s <code class="language-plaintext highlighter-rouge">#center</code> without any additional effort.</p>

<p>The major categories of concepts the Zif framework introduces are:</p>
<ul>
  <li>Basic wrappers around DRGTK concepts like <code class="language-plaintext highlighter-rouge">Zif::Sprite</code>, <code class="language-plaintext highlighter-rouge">Zif::RenderTarget</code></li>
  <li><code class="language-plaintext highlighter-rouge">Zif::Actions</code>, things which should change over time, possibly using using an easing function</li>
  <li><code class="language-plaintext highlighter-rouge">Zif::Layers</code>, ways of organizing large sets of sprites, moving them in unison, and optimizing performance</li>
  <li><code class="language-plaintext highlighter-rouge">Zif::UI</code> components like labels, buttons and scalable windows</li>
  <li>The <code class="language-plaintext highlighter-rouge">Zif::Game</code> and <code class="language-plaintext highlighter-rouge">Zif::Scene</code> classes which organize the game lifecycle</li>
  <li><code class="language-plaintext highlighter-rouge">Zif::Services</code> which support your game by keeping track of <code class="language-plaintext highlighter-rouge">Zif::Actions</code>, inputs, your image assets, and performance</li>
</ul>

<p>Finally, Zif has been designed to work as a whole, or by only bringing in the parts you need.  There is some level of dependency relationships between these concepts (<code class="language-plaintext highlighter-rouge">Zif::RenderTarget</code> doesn’t work without <code class="language-plaintext highlighter-rouge">Zif::Sprite</code>, for example), but an effort was made to document this precisely, so you should be able to pick and choose only the concepts you want to use.</p>

<h1 id="feature-overview">Feature Overview</h1>

<h2 id="basic-features">Basic Features</h2>

<h3 id="zifsprite"><code class="language-plaintext highlighter-rouge">Zif::Sprite</code></h3>
<p>This class is the basis for most of the framework.  It’s a basic sprite (using DRGTK’s <a href="http://docs.dragonruby.org/#----attr_sprite.rb">attr_sprite</a> ), which combines actions / animations, click handling, mass assignment and more.</p>

<p><strong>Example usage</strong>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dragon</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Sprite</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="mi">300</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">y</span> <span class="o">=</span> <span class="mi">300</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">w</span> <span class="o">=</span> <span class="mi">82</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">h</span> <span class="o">=</span> <span class="mi">66</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">path</span> <span class="o">=</span> <span class="s2">"sprites/dragon_1.png"</span>
<span class="k">end</span>
<span class="vg">$gtk</span><span class="p">.</span><span class="nf">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">sprites</span> <span class="o">&lt;&lt;</span> <span class="n">dragon</span>
</code></pre></div></div>

<p>See the documentation of <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Sprite.html"><code class="language-plaintext highlighter-rouge">Zif::Sprite</code></a> for details.</p>

<p>See the <code class="language-plaintext highlighter-rouge">ExampleApp::UISample</code> scene for a working example.</p>

<h3 id="zifcompoundsprite"><code class="language-plaintext highlighter-rouge">Zif::CompoundSprite</code></h3>
<p>This class acts like a (inherits from) <code class="language-plaintext highlighter-rouge">Sprite</code> but can itself accept a list of <code class="language-plaintext highlighter-rouge">@sprites</code> and <code class="language-plaintext highlighter-rouge">@labels</code>, like <code class="language-plaintext highlighter-rouge">$gtk.args.outputs</code>.  Sprites and labels added to these arrays will be drawn using the <code class="language-plaintext highlighter-rouge">CompoundSprite#draw_override</code> method, which is checked by DragonRuby GTK during the draw cycle.</p>

<p><strong>Example usage</strong>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alduin</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Sprite</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">y</span> <span class="o">=</span> <span class="mi">100</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">w</span> <span class="o">=</span> <span class="mi">82</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">h</span> <span class="o">=</span> <span class="mi">66</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">path</span> <span class="o">=</span> <span class="s2">"sprites/dragon_1.png"</span>
<span class="k">end</span>

<span class="n">bahamut</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Sprite</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="mi">200</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">y</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">w</span> <span class="o">=</span> <span class="mi">82</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">h</span> <span class="o">=</span> <span class="mi">66</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">flip_horizontally</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">path</span> <span class="o">=</span> <span class="s2">"sprites/dragon_1.png"</span>
<span class="k">end</span>

<span class="c1"># Now we have 2 dragons facing each other, but we are not adding these</span>
<span class="c1"># to args.outputs.sprites individually.</span>
<span class="c1"># They are on a battlefield and can be moved in unison!</span>
<span class="n">battlefield</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">CompoundSprite</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">cs</span><span class="o">|</span>
  <span class="n">cs</span><span class="p">.</span><span class="nf">sprites</span> <span class="o">=</span> <span class="p">[</span><span class="n">alduin</span><span class="p">,</span> <span class="n">bahamut</span><span class="p">]</span>
  <span class="n">cs</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="mi">130</span> <span class="c1"># This causes bahamut to appear at x == 330 on screen</span>
  <span class="n">cs</span><span class="p">.</span><span class="nf">y</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># This causes alduin to appear at y == 120 on screen</span>
  <span class="n">cs</span><span class="p">.</span><span class="nf">w</span> <span class="o">=</span> <span class="mi">300</span> <span class="c1"># Should be at least as wide as the farthest x value + width (200+82)</span>
  <span class="n">cs</span><span class="p">.</span><span class="nf">h</span> <span class="o">=</span> <span class="mi">200</span> <span class="c1"># Should be at least as high as the largest y value + height (100+66)</span>
  <span class="c1"># No path is defined --</span>
  <span class="c1"># CompoundSprite is for organization only and does not display directly.</span>
<span class="k">end</span>

<span class="c1"># Add the battlefield to outputs.</span>
<span class="vg">$gtk</span><span class="p">.</span><span class="nf">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">sprites</span> <span class="o">&lt;&lt;</span> <span class="n">battlefield</span>
</code></pre></div></div>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/CompoundSprite.html"><code class="language-plaintext highlighter-rouge">Zif::CompoundSprite</code></a></p>

<p>See the <code class="language-plaintext highlighter-rouge">ExampleApp::CompoundSpriteTest</code> scene for a working example.</p>

<p><img src="https://github.com/danhealy/docs/blob/main/dragonruby-zif/compound_sprite.gif?raw=true" alt="" /></p>

<h3 id="zifrendertarget"><code class="language-plaintext highlighter-rouge">Zif::RenderTarget</code></h3>

<p>A render target in DRGTK is a way to programmatically create a static image out of sprites.  It acts just like <code class="language-plaintext highlighter-rouge">$gtk.args.outputs</code> in that it accepts an array of <code class="language-plaintext highlighter-rouge">sprites</code> and other <code class="language-plaintext highlighter-rouge">primitives</code>.  It gets rendered into memory at the end of the tick where it is referenced out of <code class="language-plaintext highlighter-rouge">$gtk.args.outputs[...]</code>, based on its contents.  To display the result, you need to send <code class="language-plaintext highlighter-rouge">$gtk.args.outputs</code> a sprite which references the name of the render target as its <code class="language-plaintext highlighter-rouge">path</code>.</p>

<p>Render targets are great for increasing the performance of your game by rendering a large collection of sprites once, and then just reusing that render later. It’s also good for displaying the same image composed of many sprites multiple times (think minimap or mirrors).</p>

<p>The Zif class <code class="language-plaintext highlighter-rouge">Zif::RenderTarget</code> wraps this functionality.  It holds references to the <code class="language-plaintext highlighter-rouge">Zif::RenderTarget#sprites</code> and all of the configuration options necessary to invoke this concept in DragonRuby GTK.  It also includes a <code class="language-plaintext highlighter-rouge">Zif::Sprite</code> referencing the created image in <code class="language-plaintext highlighter-rouge">Zif::RenderTarget#containing_sprite</code>.</p>

<p><strong>Example usage</strong>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">paint_canvas</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">RenderTarget</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">:my_paint_canvas</span><span class="p">,</span>
  <span class="ss">bg_color: :white</span><span class="p">,</span>
  <span class="ss">width: </span><span class="mi">1000</span><span class="p">,</span>
  <span class="ss">height: </span><span class="mi">500</span>
<span class="p">)</span>
<span class="n">paint_canvas</span><span class="p">.</span><span class="nf">sprites</span> <span class="o">&lt;&lt;</span> <span class="vi">@all_current_brushstrokes</span>
<span class="n">paint_canvas</span><span class="p">.</span><span class="nf">redraw</span>
<span class="vg">$gtk</span><span class="p">.</span><span class="nf">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">static_sprites</span> <span class="o">&lt;&lt;</span> <span class="n">paint_canvas</span><span class="p">.</span><span class="nf">containing_sprite</span>

<span class="c1"># Some time later, you can add new brush strokes and delete a rectangle:</span>

<span class="n">minimap</span> <span class="o">=</span> <span class="c1"># ... a different sprite referencing the RenderTarget as path</span>
<span class="n">new_brushstroke</span> <span class="o">=</span> <span class="c1"># ... a new Sprite to add to the render</span>
<span class="n">erase_rect</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span> <span class="c1"># Let's say you erased something, too</span>
<span class="n">paint_canvas</span><span class="p">.</span><span class="nf">redraw_from_buffer</span><span class="p">([</span><span class="n">new_brushstroke</span><span class="p">],</span> <span class="n">erase_rect</span><span class="p">,</span> <span class="p">[</span><span class="n">minimap</span><span class="p">])</span>
</code></pre></div></div>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/RenderTarget.html"><code class="language-plaintext highlighter-rouge">Zif::RenderTarget</code></a></p>

<p>See the <code class="language-plaintext highlighter-rouge">ExampleApp::DoubleBufferRenderTest</code> scene for a working example.</p>

<h3 id="zifgame"><code class="language-plaintext highlighter-rouge">Zif::Game</code></h3>
<p>This is designed to be the base class for your game.  It’s mainly responsible for Scene switching and yielding to <code class="language-plaintext highlighter-rouge">Zif::Scene#perform_tick</code> as described below, but also it automatically registers all the <code class="language-plaintext highlighter-rouge">Zif::Services</code> and provides standard functionality around this, including exception handling.</p>

<p><strong>Example usage:</strong></p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># =-=-=- In your app/my_game.rb -=-=-=</span>
<span class="k">class</span> <span class="nc">MyGame</span> <span class="o">&lt;</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Game</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="k">super</span><span class="p">()</span>
    <span class="c1"># do anything here, like register services...</span>
    <span class="no">MyOneTime</span><span class="p">.</span><span class="nf">setups</span>

    <span class="c1"># RainbowRoadScene is a Zif::Scene subclass</span>
    <span class="n">register_scene</span><span class="p">(</span><span class="ss">:rainbow_road</span><span class="p">,</span> <span class="no">RainbowRoadScene</span><span class="p">)</span>

    <span class="c1"># (OpeningScene is also a Zif::Scene subclass)</span>
    <span class="vi">@scene</span> <span class="o">=</span> <span class="no">OpeningScene</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># =-=-=- In your app/main.rb -=-=-=</span>
<span class="c1"># Require all of the Zif library:</span>
<span class="nb">require</span> <span class="s1">'app/lib/zif/require.rb'</span>
<span class="nb">require</span> <span class="s1">'my_game.rb'</span>
<span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="nf">tick_count</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="vg">$game</span> <span class="o">=</span> <span class="no">MyGame</span><span class="p">.</span><span class="nf">new</span>
    <span class="vg">$game</span><span class="p">.</span><span class="nf">scene</span><span class="p">.</span><span class="nf">prepare_scene</span> <span class="c1"># if needed on first scene</span>
  <span class="k">end</span>
  <span class="vg">$game</span><span class="o">&amp;</span><span class="p">.</span><span class="nf">perform_tick</span>
<span class="k">end</span>
</code></pre></div></div>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Game.html"><code class="language-plaintext highlighter-rouge">Zif::Game</code></a></p>

<p>See <code class="language-plaintext highlighter-rouge">ExampleApp::ZifExample</code> for a working example.</p>

<h3 id="zifscene"><code class="language-plaintext highlighter-rouge">Zif::Scene</code></h3>

<p>A <code class="language-plaintext highlighter-rouge">Scene</code> is a full-screen view of your game.  The concept in <code class="language-plaintext highlighter-rouge">Zif::Game</code> is to show one <code class="language-plaintext highlighter-rouge">Scene</code> at a time.  So each <code class="language-plaintext highlighter-rouge">Scene</code> in your game should be a subclass of <code class="language-plaintext highlighter-rouge">Zif::Scene</code> which overrides <code class="language-plaintext highlighter-rouge">Zif::Scene#perform_tick</code>.  Using the structure in <code class="language-plaintext highlighter-rouge">Zif::Game</code>, <code class="language-plaintext highlighter-rouge">#perform_tick</code> comes after input handling and before updating <code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable</code>s.  So your subclass should use <code class="language-plaintext highlighter-rouge">#perform_tick</code> to add/remove <code class="language-plaintext highlighter-rouge">Zif::Clickable</code>s/<code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable</code>s, and respond to any detected input.  Switching scenes is handled in <code class="language-plaintext highlighter-rouge">Zif::Game</code>, based on the return value of <code class="language-plaintext highlighter-rouge">#perform_tick</code>.</p>

<p>You can optionally define <code class="language-plaintext highlighter-rouge">Zif::Scene#prepare_scene</code> - a method invoked prior to the first tick it becomes the active scene, and <code class="language-plaintext highlighter-rouge">Zif::Scene#unload_scene</code> which is invoked after the Scene has been switched out.</p>

<p><strong>Example usage:</strong></p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OpeningScene</span> <span class="o">&lt;</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Scene</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="c1"># If OpeningScene is registered by symbol using Zif::Game#register_scene,</span>
    <span class="c1"># this initialize will happen each time the game switches to this scene.</span>
    <span class="c1"># Otherwise you could instantiate this scene somewhere and simply</span>
    <span class="c1"># return it from another scene's #perform_tick</span>
    <span class="vi">@dragon</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Sprite</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># ....</span>
    <span class="vi">@hello</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">UI</span><span class="o">::</span><span class="no">Label</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Hello World!"</span><span class="p">).</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">label</span><span class="o">|</span>
      <span class="n">label</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="mi">100</span>
      <span class="n">label</span><span class="p">.</span><span class="nf">y</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="k">end</span>
    <span class="vi">@current_scene_tick_count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">prepare_scene</span>
    <span class="c1"># You probably want to remove the things registered with the services when</span>
    <span class="c1"># scenes change. You can remove items explicitly using #remove_.., but</span>
    <span class="c1"># #reset_.. will clear everything. You can also do this when a scene is</span>
    <span class="c1"># being changed away from, using the #unload_scene method.</span>
    <span class="vg">$game</span><span class="p">.</span><span class="nf">services</span><span class="p">[</span><span class="ss">:action_service</span><span class="p">].</span><span class="nf">reset_actionables</span>
    <span class="vg">$game</span><span class="p">.</span><span class="nf">services</span><span class="p">[</span><span class="ss">:input_service</span><span class="p">].</span><span class="nf">reset</span>
    <span class="vg">$gtk</span><span class="p">.</span><span class="nf">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">static_sprites</span><span class="p">.</span><span class="nf">clear</span>
    <span class="vg">$gtk</span><span class="p">.</span><span class="nf">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">static_labels</span><span class="p">.</span><span class="nf">clear</span>

    <span class="c1"># Now you can use this to do one-time setup code.</span>
    <span class="vg">$game</span><span class="p">.</span><span class="nf">services</span><span class="p">[</span><span class="ss">:action_service</span><span class="p">].</span><span class="nf">register_actionable</span><span class="p">(</span><span class="vi">@dragon</span><span class="p">)</span>
    <span class="vg">$game</span><span class="p">.</span><span class="nf">services</span><span class="p">[</span><span class="ss">:input_service</span><span class="p">].</span><span class="nf">register_clickable</span><span class="p">(</span><span class="vi">@dragon</span><span class="p">)</span>

    <span class="c1"># Best practice is to use static outputs, this gives you a lot more</span>
    <span class="c1"># performance and there is no need to append to the array inside</span>
    <span class="c1"># #perform_tick. The only downside is that you have to manage this list</span>
    <span class="c1"># manually.  You can remove sprites at any time in #perform_tick.</span>
    <span class="vg">$gtk</span><span class="p">.</span><span class="nf">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">static_sprites</span> <span class="o">&lt;&lt;</span> <span class="vi">@dragon</span>
    <span class="vg">$gtk</span><span class="p">.</span><span class="nf">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">static_labels</span> <span class="o">&lt;&lt;</span> <span class="vi">@hello</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">perform_tick</span>
    <span class="vi">@current_scene_tick_count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="vi">@hello</span><span class="p">.</span><span class="nf">text</span> <span class="o">=</span> <span class="s2">"Hello World! </span><span class="si">#{</span><span class="vi">@current_scene_tick_count</span><span class="si">}</span><span class="s2">"</span>

    <span class="c1"># Tell Zif::Game to attempt to switch to the scene registered with the name</span>
    <span class="c1"># :rainbow_road after some time</span>
    <span class="k">return</span> <span class="ss">:rainbow_road</span> <span class="k">if</span> <span class="vi">@current_scene_tick_count</span> <span class="o">&gt;</span> <span class="mi">200</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Scene.html"><code class="language-plaintext highlighter-rouge">Zif::Scene</code></a></p>

<p>See <code class="language-plaintext highlighter-rouge">ExampleApp::ZifExampleScene</code> for a working example - this scene class is shared amongst the example app, so it’s designed around the auto-advancing scene behavior.</p>

<h2 id="zifactions-aka-tweening-easing"><code class="language-plaintext highlighter-rouge">Zif::Actions</code> (aka tweening, easing)</h2>
<p>Inspried by <a href="https://developer.apple.com/documentation/spritekit/skaction">SpriteKit’s Actions</a> and <a href="https://www.youtube.com/watch?v=mr5xkf6zSzk">Squirrel Eiserloh’s GDC talk on nonlinear transformations</a>.</p>

<h3 id="zifactionsaction--zifactionsactionable"><code class="language-plaintext highlighter-rouge">Zif::Actions::Action</code> &amp; <code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable</code></h3>
<p>An Action is a transition of a set of attributes over time using an easing function (aka tweening, easing).</p>

<p>Your objects can accept Actions by mixing in <code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable</code> and calling the <code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable#run_action</code> method.  You can specify the number of times the Action should be repeated, and set a callback for when the Action is finished.</p>

<p>An Actionable can have several Actions running simultaneously, and they can be started and stopped manually.</p>

<p><strong>Example usage:</strong></p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># @dragon is a Zif::Sprite and therefore an Actionable, and already registered</span>
<span class="c1"># with the ActionService.  Move from starting position to 1000x over 1 second,</span>
<span class="c1"># starting slowly, then flip the sprite at the end.  Note that starting</span>
<span class="c1"># position is just taken from the current state of @dragon rather than</span>
<span class="c1"># specified.</span>
<span class="vi">@dragon</span><span class="p">.</span><span class="nf">run_action</span><span class="p">(</span>
  <span class="vi">@dragon</span><span class="p">.</span><span class="nf">new_action</span><span class="p">({</span><span class="ss">x: </span><span class="mi">1000</span><span class="p">},</span> <span class="ss">duration: </span><span class="mi">1</span><span class="p">.</span><span class="nf">seconds</span><span class="p">,</span> <span class="ss">easing: :smooth_start</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@dragon</span><span class="p">.</span><span class="nf">flip_horizontally</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="k">end</span>
<span class="p">)</span>
</code></pre></div></div>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Actions/Action.html"><code class="language-plaintext highlighter-rouge">Zif::Actions::Action</code></a>, <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Actions/Actionable.html"><code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable</code></a>, <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Services/ActionService.html"><code class="language-plaintext highlighter-rouge">Zif::Services::ActionService</code></a></p>

<p>Take a look at the code for <code class="language-plaintext highlighter-rouge">@dragon</code> inside <code class="language-plaintext highlighter-rouge">ExampleApp::UISample</code> for a simple working example.</p>

<p>More complicated examples can be seen in <code class="language-plaintext highlighter-rouge">ExampleApp::World</code> - The dragon is using Actions to move across the map, and the map itself is panning to track the dragon using Actions.  The <code class="language-plaintext highlighter-rouge">ExampleApp::Pixie</code> class demonstrates using the <code class="language-plaintext highlighter-rouge">follow:</code> param to set the finish condition based on another object.</p>

<h3 id="zifactionssequence"><code class="language-plaintext highlighter-rouge">Zif::Actions::Sequence</code></h3>
<p>A Sequence is a series of <code class="language-plaintext highlighter-rouge">Zif::Actions::Action</code> to be run in order.  Behaves like an Action, you run it using the same <code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable#run_action</code> method.  You can specify the number of times the sequence should be repeated, and set a callback for when the sequence is finished.</p>

<p><strong>Example usage:</strong></p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@dragon</span><span class="p">.</span><span class="nf">run_action</span><span class="p">(</span>
  <span class="no">Zif</span><span class="o">::</span><span class="no">Sequence</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="p">[</span>
      <span class="c1"># Move from starting position to 1000x over 1 second, starting slowly,</span>
      <span class="c1"># then flip the sprite at the end</span>
      <span class="vi">@dragon</span><span class="p">.</span><span class="nf">new_action</span><span class="p">(</span>
        <span class="p">{</span><span class="ss">x: </span><span class="mi">1000</span><span class="p">},</span>
        <span class="ss">duration: </span><span class="mi">1</span><span class="p">.</span><span class="nf">seconds</span><span class="p">,</span>
        <span class="ss">easing: :smooth_start</span>
      <span class="p">)</span> <span class="p">{</span> <span class="vi">@dragon</span><span class="p">.</span><span class="nf">flip_horizontally</span> <span class="o">=</span> <span class="kp">true</span> <span class="p">},</span>
      <span class="c1"># Move from the new position (1000x) back to the start 600x over 2</span>
      <span class="c1"># seconds, stopping slowly, then flip again</span>
      <span class="vi">@dragon</span><span class="p">.</span><span class="nf">new_action</span><span class="p">(</span>
        <span class="p">{</span><span class="ss">x: </span><span class="mi">600</span><span class="p">},</span>
        <span class="ss">duration: </span><span class="mi">2</span><span class="p">.</span><span class="nf">seconds</span><span class="p">,</span>
        <span class="ss">easing: :smooth_stop</span>
      <span class="p">)</span> <span class="p">{</span> <span class="vi">@dragon</span><span class="p">.</span><span class="nf">flip_horizontally</span> <span class="o">=</span> <span class="kp">false</span> <span class="p">}</span>
    <span class="p">],</span>
    <span class="ss">repeat: :forever</span>
  <span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Actions/Sequence.html"><code class="language-plaintext highlighter-rouge">Zif::Actions::Sequence</code></a></p>

<p>Again, take a look at the code for <code class="language-plaintext highlighter-rouge">@dragon</code> inside <code class="language-plaintext highlighter-rouge">ExampleApp::UISample</code> for a simple working example.</p>

<h3 id="zifactionsanimatable"><code class="language-plaintext highlighter-rouge">Zif::Actions::Animatable</code></h3>

<p>Animatable is a mixin to assist with sprite animations.  Under the hood, these are implemented as <code class="language-plaintext highlighter-rouge">Zif::Actions::Sequence</code>s which modify the <code class="language-plaintext highlighter-rouge">path</code> over time, and they are registered using a name.</p>

<p><strong>Example usage:</strong></p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Register the animation for a flying Dragon.</span>
 <span class="vi">@dragon</span><span class="p">.</span><span class="nf">new_basic_animation</span><span class="p">(</span>
   <span class="ss">named: :fly</span><span class="p">,</span>
   <span class="ss">paths_and_durations: </span><span class="p">[</span>
     <span class="c1">#   +-- path for this frame</span>
     <span class="c1">#   |        +-- duration for this frame</span>
     <span class="c1">#   v        v</span>
     <span class="p">[</span><span class="s2">"dragon_1"</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="c1"># This animation uses 4 separate image files</span>
     <span class="p">[</span><span class="s2">"dragon_2"</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="c1"># Hold each frame for 4 ticks</span>
     <span class="p">[</span><span class="s2">"dragon_3"</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="c1"># The actual image exists at: app/sprites/dragon_3.png</span>
     <span class="p">[</span><span class="s2">"dragon_4"</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
     <span class="p">[</span><span class="s2">"dragon_3"</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
     <span class="p">[</span><span class="s2">"dragon_2"</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="c1"># Repeats forever, which takes it back to 1</span>
   <span class="p">]</span>
 <span class="p">)</span>

 <span class="c1"># We don't have to register this sequence manually using</span>
 <span class="c1"># #register_animation_sequence, the #new_basic_animation method takes care of</span>
 <span class="c1"># that for us.</span>

 <span class="c1"># So now we can run this animation:</span>
 <span class="vi">@dragon</span><span class="p">.</span><span class="nf">run_animation_sequence</span><span class="p">(</span><span class="ss">:fly</span><span class="p">)</span>
</code></pre></div></div>
<p><img src="https://github.com/danhealy/docs/blob/main/dragonruby-zif/dragon_actions.gif?raw=true" alt="" /></p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Actions/Animatable.html"><code class="language-plaintext highlighter-rouge">Zif::Actions::Animatable</code></a></p>

<h2 id="ziflayers"><code class="language-plaintext highlighter-rouge">Zif::Layers</code></h2>

<p>If your game’s play area extends beyond the screen resolution, you likely want some way of managing this!  <code class="language-plaintext highlighter-rouge">Zif::Layers</code> are designed for this use case.  They provide several different strategies for performantly rendering large numbers of sprites, organizing them by a Z-index, and moving them in unison via the <code class="language-plaintext highlighter-rouge">Zif::Layers::Camera</code> class.</p>

<h3 id="ziflayerslayergroup"><code class="language-plaintext highlighter-rouge">Zif::Layers::LayerGroup</code></h3>

<p>Creates a set of overlapping play area layers based on <code class="language-plaintext highlighter-rouge">Zif::Layers::SimpleLayer</code> (<code class="language-plaintext highlighter-rouge">Zif::RenderTarget</code>) or <code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveLayer</code> (<code class="language-plaintext highlighter-rouge">Zif::CompoundSprite</code>) and handles redrawing them.</p>

<p>Has a concept of <code class="language-plaintext highlighter-rouge">logical</code> position as a multiple of <code class="language-plaintext highlighter-rouge">tile</code> width/height, applicable to any <code class="language-plaintext highlighter-rouge">Zif::Layers::Tileable</code> layers. For example, if your tiles are <code class="language-plaintext highlighter-rouge">16px</code> wide, the 5th tile is at <code class="language-plaintext highlighter-rouge">@logical_x==4</code> but at <code class="language-plaintext highlighter-rouge">@x==64</code> on the layer.</p>

<p><strong>Example usage</strong>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tile_width_and_height</span>         <span class="o">=</span> <span class="mi">64</span>  <span class="c1"># Each tile is 64x64 pixels</span>
<span class="n">map_width_and_height_in_tiles</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># 64 * 100 = 6400x6400 pixels, 10000 tiles</span>

<span class="vi">@map</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Layers</span><span class="o">::</span><span class="no">LayerGroup</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">tile_width:     </span><span class="n">tile_width_and_height</span><span class="p">,</span>
  <span class="ss">tile_height:    </span><span class="n">tile_width_and_height</span><span class="p">,</span>
  <span class="ss">logical_width:  </span><span class="n">map_width_and_height_in_tiles</span><span class="p">,</span>
  <span class="ss">logical_height: </span><span class="n">map_width_and_height_in_tiles</span>
<span class="p">)</span>

<span class="c1"># This example is only using Zif::Layers::ActiveLayer because they are easier</span>
<span class="c1"># to set up, and it is a good place to start in terms of performance.</span>
<span class="vi">@map</span><span class="p">.</span><span class="nf">new_active_tiled_layer</span><span class="p">(</span><span class="ss">:tiles</span><span class="p">)</span>
<span class="vi">@map</span><span class="p">.</span><span class="nf">new_active_layer</span><span class="p">(</span><span class="ss">:avatar</span><span class="p">)</span>

<span class="vi">@map</span><span class="p">.</span><span class="nf">layers</span><span class="p">[</span><span class="ss">:avatar</span><span class="p">].</span><span class="nf">source_sprites</span> <span class="o">=</span> <span class="p">[</span><span class="vi">@dragon</span><span class="p">]</span>

<span class="c1"># Add a bunch of tiles</span>
<span class="n">a_new_tile</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Sprite</span><span class="p">.</span><span class="nf">new</span><span class="o">....</span>
<span class="vi">@map</span><span class="p">.</span><span class="nf">layers</span><span class="p">[</span><span class="ss">:tiles</span><span class="p">].</span><span class="nf">add_positioned_sprite</span><span class="p">(</span>
  <span class="ss">sprite: </span><span class="n">a_new_tile</span><span class="p">,</span>
  <span class="ss">logical_x: </span><span class="n">x</span><span class="p">,</span>
  <span class="ss">logical_y: </span><span class="n">y</span>
<span class="p">)</span>

<span class="c1"># Set up a camera</span>
<span class="vi">@camera</span> <span class="o">=</span> <span class="no">Zif</span><span class="o">::</span><span class="no">Layers</span><span class="o">::</span><span class="no">Camera</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">layer_sprites: </span><span class="vi">@map</span><span class="p">.</span><span class="nf">layer_containing_sprites</span><span class="p">,</span>
  <span class="ss">initial_x: </span><span class="mi">1800</span><span class="p">,</span>
  <span class="ss">initial_y: </span><span class="mi">1200</span>
<span class="p">)</span>

<span class="vg">$gtk</span><span class="p">.</span><span class="nf">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">static_sprites</span> <span class="o">&lt;&lt;</span> <span class="vi">@camera</span><span class="p">.</span><span class="nf">layers</span>

<span class="c1"># All set!  You can move your sprites (like @dragon) around.</span>
<span class="c1">#  You can control the Camera using actions.</span>
<span class="c1"># Most or all of the above code could be placed in a Zif::Scene#prepare_scene</span>
</code></pre></div></div>
<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers/LayerGroup.html"><code class="language-plaintext highlighter-rouge">Zif::Layers::LayerGroup</code></a></p>

<p>See <code class="language-plaintext highlighter-rouge">ExampleApp::World</code> for a working example.</p>

<h3 id="ziflayerssimplelayer"><code class="language-plaintext highlighter-rouge">Zif::Layers::SimpleLayer</code></h3>
<p>This layer is based on <code class="language-plaintext highlighter-rouge">Zif::RenderTarget</code> and therefore the component sprites will not be rendered until <code class="language-plaintext highlighter-rouge">Zif::RenderTarget#redraw</code> or <code class="language-plaintext highlighter-rouge">Zif::RenderTarget#redraw_from_buffer</code> is called - typically via <code class="language-plaintext highlighter-rouge">Zif::Layers::SimpleLayer#rerender</code>.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers/SimpleLayer.html"><code class="language-plaintext highlighter-rouge">Zif::Layers::SimpleLayer</code></a></p>

<h3 id="ziflayersactivelayer"><code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveLayer</code></h3>
<p>In contrast to <code class="language-plaintext highlighter-rouge">Zif::Layers::SimpleLayer</code>, <code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveLayer</code> is built on <code class="language-plaintext highlighter-rouge">Zif::CompoundSprite</code> and therefore must rerender every sprite on every tick.  This is balanced by not incurring a performance / memory penalty by rendering a sprite the size of the entire <code class="language-plaintext highlighter-rouge">Zif::Layers::LayerGroup</code> width times height.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers/ActiveLayer.html"><code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveLayer</code></a></p>

<h3 id="deciding-between-ziflayerssimplelayer--ziflayersactivelayer">Deciding between <code class="language-plaintext highlighter-rouge">Zif::Layers::SimpleLayer</code> &amp; <code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveLayer</code></h3>
<p>This depends on your application.  In general, try organizing your layers into those that don’t change at all, or only change when action (like camera movement) isn’t happening, and put those sprites into a <code class="language-plaintext highlighter-rouge">Zif::Layers::SimpleLayer</code>.  Then take all of the sprites which do need to change often, or are necessary for action, and put those in <code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveLayer</code>s.</p>

<p>You can use either <code class="language-plaintext highlighter-rouge">Zif::Layers::SimpleLayer</code> or <code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveLayer</code> directly when the sprites contained don’t need to snap to the tile grid set up in the <code class="language-plaintext highlighter-rouge">Zif::Layers::LayerGroup</code>.</p>

<h3 id="ziflayerstileable"><code class="language-plaintext highlighter-rouge">Zif::Layers::Tileable</code></h3>
<p>The Tileable mixin provides functionality to Layers to support a grid organization.  The two classes based on the Tileable mixin are <code class="language-plaintext highlighter-rouge">Zif::Layers::TiledLayer</code> and <code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveTiledLayer</code>.</p>

<p>If your sprites need to snap to a grid, you should use one of these.  See the section above for tips on choosing one or the other.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers/Tileable.html"><code class="language-plaintext highlighter-rouge">Zif::Layers::Tileable</code></a>, <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers/TiledLayer.html"><code class="language-plaintext highlighter-rouge">Zif::Layers::TiledLayer</code></a>, <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers/ActiveTiledLayer.html"><code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveTiledLayer</code></a></p>

<h3 id="ziflayersbitmaskable"><code class="language-plaintext highlighter-rouge">Zif::Layers::Bitmaskable</code></h3>
<p>A layer which extends Tileable, where the sprites are chosen automatically via bitmasked adjacency rules on the presence data layer - otherwise known as Autotiling.</p>

<p>A detailed explanation of this technique is described in the class documentation for <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers/Bitmaskable.html"><code class="language-plaintext highlighter-rouge">Zif::Layers::Bitmaskable</code></a> and at this resource:
<a href="https://gamedevelopment.tutsplus.com/tutorials/how-to-use-tile-bitmasking-to-auto-tile-your-level-layouts--cms-25673">https://gamedevelopment.tutsplus.com/tutorials/how-to-use-tile-bitmasking-to-auto-tile-your-level-layouts–cms-25673</a></p>

<p>This mixin is included in <code class="language-plaintext highlighter-rouge">Zif::Layers::BitmaskedTiledLayer</code> and <code class="language-plaintext highlighter-rouge">Zif::Layers::ActiveBitmaskedTiledLayer</code>.</p>

<h3 id="ziflayerscamera"><code class="language-plaintext highlighter-rouge">Zif::Layers::Camera</code></h3>
<p>The Camera is given a set of sprites, typically the containing sprites for a set of <code class="language-plaintext highlighter-rouge">Zif::Layers::Layerable</code>s via <code class="language-plaintext highlighter-rouge">Zif::Layers::LayerGroup#layer_containing_sprites</code>.</p>

<p>It is responsible for directing the layers to reposition based on camera movements.  Specifically, it alters each layer’s <code class="language-plaintext highlighter-rouge">source_x</code> and <code class="language-plaintext highlighter-rouge">source_y</code> values for panning.</p>

<p>This class includes <code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable</code>, so you can pan the camera using a <code class="language-plaintext highlighter-rouge">Zif::Actions::Action</code>.</p>

<p>It has the capability of issuing camera movements based on following a particular sprite on a layer (like a player character).</p>

<p>It also has the capability of zooming in and out, by controlling each layer’s <code class="language-plaintext highlighter-rouge">source_w</code> and <code class="language-plaintext highlighter-rouge">source_h</code>. It can be registered as a scrollable with <code class="language-plaintext highlighter-rouge">Zif::Services::InputService</code>.</p>

<p><strong>Example usage:</strong></p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Using the setup example from Zif::Layers::LayerGroup</span>
<span class="c1"># Assumes @camera has been registered as an actionable</span>
<span class="vi">@camera</span><span class="p">.</span><span class="nf">start_following</span><span class="p">(</span><span class="vi">@dragon</span><span class="p">)</span>
</code></pre></div></div>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers/Camera.html"><code class="language-plaintext highlighter-rouge">Zif::Layers::Camera</code></a></p>

<p>A working example is available in <code class="language-plaintext highlighter-rouge">ExampleApp::World</code>.</p>

<p><img src="https://github.com/danhealy/docs/blob/main/dragonruby-zif/world.gif?raw=true" alt="" /></p>

<h2 id="zifui"><code class="language-plaintext highlighter-rouge">Zif::UI</code></h2>
<p>Simple UI components. Examples for these classes exist in <code class="language-plaintext highlighter-rouge">ExampleApp::UISample</code>.</p>

<h3 id="zifuilabel"><code class="language-plaintext highlighter-rouge">Zif::UI::Label</code></h3>
<p>A wrapper for the <code class="language-plaintext highlighter-rouge">label</code> DRGTK primitive: displaying text using a font, size, alignment, color. Includes <code class="language-plaintext highlighter-rouge">Zif::Actions::Actionable</code>!  Supports text truncation by calculating it’s own width, and supports word wrapping.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/UI/Label.html"><code class="language-plaintext highlighter-rouge">Zif::UI::Label</code></a></p>

<p><img src="https://github.com/danhealy/docs/blob/main/dragonruby-zif/resize_word_wrap.gif?raw=true" alt="" /></p>

<h3 id="zifuiinput"><code class="language-plaintext highlighter-rouge">Zif::UI::Input</code></h3>
<p>This is a Label which includes <code class="language-plaintext highlighter-rouge">Zif::KeyPressable</code> and will add the keys being pressed to itself.  Useful for form fields.  You must manually manage its registration with the <code class="language-plaintext highlighter-rouge">Zif::Services::InputService</code> as well as control its focus via <code class="language-plaintext highlighter-rouge">@has_focus</code>.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/UI/Input.html"><code class="language-plaintext highlighter-rouge">Zif::UI::Input</code></a>, <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/KeyPressable.html"><code class="language-plaintext highlighter-rouge">Zif::KeyPressable</code></a></p>

<p>A working example is available in <code class="language-plaintext highlighter-rouge">ExampleApp::UISample</code>, implemented by <code class="language-plaintext highlighter-rouge">ExampleApp::FormField</code> and <code class="language-plaintext highlighter-rouge">ExampleApp::FocusCheck</code></p>

<p><img src="https://github.com/danhealy/docs/blob/main/dragonruby-zif/input_field.gif?raw=true" alt="" /></p>

<h3 id="zifuitwostagebutton"><code class="language-plaintext highlighter-rouge">Zif::UI::TwoStageButton</code></h3>
<p>This is the classic UI button, which has two sprites: a normal state, and a pressed state.  It accepts a label which is centered by default.</p>

<p>This is implemented using <code class="language-plaintext highlighter-rouge">Zif::CompoundSprite</code>, so it is a <code class="language-plaintext highlighter-rouge">Zif::Clickable</code>, and by default it has already set up the click handlers to handle switching states based on clicks.  You can pass a block to the constructor, this will be executed if the button is clicked and the mouse click goes up within the rectangle of the button. (You can click down on the button, move the mouse outside, and let go - it will not trigger the callback in this case.)</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/UI/TwoStageButton.html"><code class="language-plaintext highlighter-rouge">Zif::UI::TwoStageButton</code></a></p>

<p><img src="https://github.com/danhealy/docs/blob/main/dragonruby-zif/press_button.gif?raw=true" alt="" /></p>

<h3 id="zifuininepanel"><code class="language-plaintext highlighter-rouge">Zif::UI::NinePanel</code></h3>
<p>Nine-slice sprites, built on <code class="language-plaintext highlighter-rouge">Zif::CompoundSprite</code>: https://en.wikipedia.org/wiki/9-slice_scaling</p>

<p>Because the implementation of this partially depends on the visual assets you are using, this is an <strong>abstract</strong> class.  You are expected to subclass this to:</p>
<ul>
  <li>override <code class="language-plaintext highlighter-rouge">#initialize</code> with <code class="language-plaintext highlighter-rouge">super</code> to set the <code class="language-plaintext highlighter-rouge">@corners</code>, <code class="language-plaintext highlighter-rouge">@edges</code> and <code class="language-plaintext highlighter-rouge">@fill</code> with sprites</li>
  <li>override <code class="language-plaintext highlighter-rouge">#resize_width</code> and <code class="language-plaintext highlighter-rouge">#resize_height</code> to manage resizing the above sprites in a sensible way</li>
</ul>

<p>Ideally, these corners and edges would be <code class="language-plaintext highlighter-rouge">Zif::Sprite</code>s and therefore <code class="language-plaintext highlighter-rouge">Zif::Clickable</code>s - you could use this to implement click &amp; drag, or drag-to-resize using the resize methods.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/UI/NinePanel.html"><code class="language-plaintext highlighter-rouge">Zif::UI::NinePanel</code></a></p>

<h2 id="zifservices--zifservicesservicegroup"><code class="language-plaintext highlighter-rouge">Zif::Services</code> &amp; <code class="language-plaintext highlighter-rouge">Zif::Services::ServiceGroup</code></h2>
<p>Services are game utilities which can be accessed from any context within your app.</p>

<p>If you use <code class="language-plaintext highlighter-rouge">Zif::Game</code>, every Zif service will be set up for you using <code class="language-plaintext highlighter-rouge">Zif::Services::ServiceGroup</code>, and registered in the <code class="language-plaintext highlighter-rouge">Game</code>’s instance variable <code class="language-plaintext highlighter-rouge">@services</code> named by a symbol.  For example, you will be able to access the <code class="language-plaintext highlighter-rouge">Zif::Services::ActionService</code> by <code class="language-plaintext highlighter-rouge">$game.services[:action_service]</code>.  This is because <code class="language-plaintext highlighter-rouge">Zif::Game</code> runs <code class="language-plaintext highlighter-rouge">@services.register(:action_service, Zif::ActionService.new)</code> during initialization, and by convention, both <code class="language-plaintext highlighter-rouge">$game</code> and <code class="language-plaintext highlighter-rouge">$services</code> are available as global variables.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Services/ServiceGroup.html"><code class="language-plaintext highlighter-rouge">Zif::Services::ServiceGroup</code></a></p>

<h3 id="zifservicesactionservice"><code class="language-plaintext highlighter-rouge">Zif::Services::ActionService</code></h3>
<p>See <code class="language-plaintext highlighter-rouge">Zif::Actions</code> above for more information on Actions.</p>

<p>Each tick, checks sprites which have been registered for running actions.</p>

<p>If you are using <code class="language-plaintext highlighter-rouge">Zif::Game</code>, this service is registered as <code class="language-plaintext highlighter-rouge">:action_service</code>.  All you need to do is register any object which needs to be checked for running <code class="language-plaintext highlighter-rouge">Action</code>s by using <code class="language-plaintext highlighter-rouge">Zif::Services::ActionService#register_actionable</code>.</p>

<p>If you are not using <code class="language-plaintext highlighter-rouge">Zif::Game</code>, ensure you are calling <code class="language-plaintext highlighter-rouge">Zif::Services::ActionService#run_all_actions</code> once per tick.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Services/ActionService.html"><code class="language-plaintext highlighter-rouge">Zif::Services::ActionService</code></a></p>

<h3 id="zifservicesinputservice"><code class="language-plaintext highlighter-rouge">Zif::Services::InputService</code></h3>
<p>Keeps track of sprites and other objects interested in responding to clicks and scroll events, and passes the events over to them when they occur.</p>

<p>If you are using <code class="language-plaintext highlighter-rouge">Zif::Game</code>, this service is registered as <code class="language-plaintext highlighter-rouge">:input_service</code>.  All you need to do is register any sprite which needs  to respond to clicks or scrolls using <code class="language-plaintext highlighter-rouge">Zif::Services::InputService#register_clickable</code> and <code class="language-plaintext highlighter-rouge">#register_scrollable</code>.</p>

<p>Clickable sprites should mixin <code class="language-plaintext highlighter-rouge">Zif::Clickable</code> or be compatible by defining a <code class="language-plaintext highlighter-rouge">#clicked?</code> method and <code class="language-plaintext highlighter-rouge">@on_mouse_up</code> instance variable callbacks.  All <code class="language-plaintext highlighter-rouge">Zif::Sprite</code>s follow this convention.</p>

<p>Scrollable objects should define <code class="language-plaintext highlighter-rouge">#scrolled?</code>.  <code class="language-plaintext highlighter-rouge">Zif::Layers::Camera</code> uses this.</p>

<p>Objects which should receive key presses should mixin <code class="language-plaintext highlighter-rouge">Zif::KeyPressable</code>.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Services/InputService.html"><code class="language-plaintext highlighter-rouge">Zif::Services::InputService</code></a>, <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Clickable.html"><code class="language-plaintext highlighter-rouge">Zif::Clickable</code></a>, <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/KeyPressable.html"><code class="language-plaintext highlighter-rouge">Zif::KeyPressable</code></a></p>

<p><a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Layers.html"><code class="language-plaintext highlighter-rouge">Zif::Layers</code></a> handle clicks in a hierarchical way, see documentation for info.</p>

<p>There are many working clickable examples in the <code class="language-plaintext highlighter-rouge">ExampleApp</code>.</p>

<h3 id="zifservicesspriteregistry"><code class="language-plaintext highlighter-rouge">Zif::Services::SpriteRegistry</code></h3>
<p>This service is for registering your sprite assets once, and assists in creating new <code class="language-plaintext highlighter-rouge">Zif::Sprite</code> instances from the parameters described when registering.</p>

<p><strong>Example usage:</strong></p>

<p>The following code will create a <code class="language-plaintext highlighter-rouge">Zif::Sprite</code> with width and height of 82px and 66px, referencing a <code class="language-plaintext highlighter-rouge">path</code> of <code class="language-plaintext highlighter-rouge">sprites/dragon_1.png</code>.  The second line demonstrates getting a fresh <code class="language-plaintext highlighter-rouge">Zif::Sprite</code> copy with these settings.</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$services</span><span class="p">[</span><span class="ss">:sprite_registry</span><span class="p">].</span><span class="nf">register_basic_sprite</span><span class="p">(</span><span class="s2">"dragon_1"</span><span class="p">,</span> <span class="ss">width: </span><span class="mi">82</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">66</span><span class="p">)</span>
<span class="vi">@dragon</span> <span class="o">=</span> <span class="vg">$services</span><span class="p">[</span><span class="ss">:sprite_registry</span><span class="p">].</span><span class="nf">construct</span><span class="p">(</span><span class="s2">"dragon_1"</span><span class="p">)</span>
</code></pre></div></div>

<p>The autotiling feature of <code class="language-plaintext highlighter-rouge">Zif::Layers::Bitmaskable</code> is designed around having the tile assets registered in this service.</p>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Services/SpriteRegistry.html"><code class="language-plaintext highlighter-rouge">Zif::Services::SpriteRegistry</code></a></p>

<h3 id="zifservicesticktraceservice--ziftraceable"><code class="language-plaintext highlighter-rouge">Zif::Services::TickTraceService</code> &amp; <code class="language-plaintext highlighter-rouge">Zif::Traceable</code></h3>
<p>Generally, you want your game to run at a full 60fps.  If your tick takes longer than 16.6ms, you’ll drop below that number.  This service is designed to report when a tick has taken longer than a threshold (20ms by default), and hopefully narrow down the slowest section of code. <code class="language-plaintext highlighter-rouge">Zif::Services::TickTraceService#reset_tick</code> must be called at the beginning of a tick, and then <code class="language-plaintext highlighter-rouge">#finish</code> at the end.  If you use <code class="language-plaintext highlighter-rouge">Zif::Game</code>, this is done for you.</p>

<p>The <code class="language-plaintext highlighter-rouge">Zif::Traceable</code> mixin helps you use this service from an object, all you need to do is <code class="language-plaintext highlighter-rouge">include Zif::Traceable</code> in any class you want to mark, set the <code class="language-plaintext highlighter-rouge">@tracer_service_name</code> ivar to <code class="language-plaintext highlighter-rouge">:tracer</code>, and then <code class="language-plaintext highlighter-rouge">mark('a section of code')</code>.  By convention, you should include the name of the method which calls <code class="language-plaintext highlighter-rouge">#mark</code>:  <code class="language-plaintext highlighter-rouge">mark('#my_method: a section of code')</code></p>

<p><code class="language-plaintext highlighter-rouge">Zif::Traceable#mark_and_print</code> is also available, if you want to print to the console when you mark the section.</p>

<p><strong>Example output:</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">ExampleApp::UISample</code> scene includes a little button to simulate a slow tick (it sleeps for half a second).  This is the console output from clicking that button.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ExampleApp::UISample: delay_button: Button was clicked - demonstrating Tick Trace service
ExampleApp::UISample: delay_button: Woke up from 500ms second nap
================================================================================
Zif::Services::TickTraceService: Slow tick. 504.920ms elapsed &gt;  20.000ms threshold, longest step 'ExampleApp::UISample: delay_button: Woke up from 500ms second nap' 503.468ms:
       mark     delta label
    0.016ms   0.016ms ExampleApp::ZifExample: #standard_tick: begin
    0.895ms   0.879ms ExampleApp::UISample: delay_button: Button was clicked - demonstrating Tick Trace service
  504.363ms 503.468ms ExampleApp::UISample: delay_button: Woke up from 500ms second nap
  504.406ms   0.043ms ExampleApp::ZifExample: #standard_tick: input_service #process_click
  504.420ms   0.014ms ExampleApp::UISample: #perform_tick: begin
  504.445ms   0.025ms ExampleApp::UISample: #update_metal_panel: begin
  504.507ms   0.062ms ExampleApp::UISample: #update_metal_panel: complete
  504.519ms   0.012ms ExampleApp::UISample: #update_glass_panel: begin
  504.552ms   0.033ms ExampleApp::UISample: #update_glass_panel: complete
  504.564ms   0.012ms ExampleApp::UISample: #update_progress_bar: begin
  504.612ms   0.048ms ExampleApp::UISample: #update_progress_bar: complete
  504.624ms   0.012ms ExampleApp::UISample: #update_interactable_button: begin
  504.636ms   0.012ms ExampleApp::UISample: #update_interactable_button: complete
  504.646ms   0.010ms ExampleApp::UISample: #perform_tick: finished updates
  504.742ms   0.096ms ExampleApp::UISample: #perform_tick: finished super
  504.754ms   0.012ms ExampleApp::ZifExample: #standard_tick: Scene #perform_tick complete
  504.772ms   0.018ms ExampleApp::ZifExample: #standard_tick: Scene switching handled
  504.901ms   0.129ms ExampleApp::ZifExample: #standard_tick: Action service complete
  504.920ms   0.019ms ExampleApp::ZifExample: #standard_tick: Complete
</code></pre></div></div>

<p>See the documentation for details: <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Services/TickTraceService.html"><code class="language-plaintext highlighter-rouge">Zif::Services::TickTraceService</code></a>, <a href="https://danhealy.github.io/dragonruby-zif/docs/Zif/Traceable.html"><code class="language-plaintext highlighter-rouge">Zif::Traceable</code></a></p>

<h1 id="coming-soon">Coming Soon</h1>
<p>Some features and things being considered for this library:</p>
<ul>
  <li>Official support and/or examples for integrating with Draco ECS, and with Tiled tilemaps</li>
  <li>Parallax camera example</li>
  <li>Physics, or acceleration equivalent of Actions</li>
  <li>Ports of DRGTK Sample apps to “Zif style”</li>
</ul>

<p>If these sound interesting to you, make some noise in the <a href="https://discord.gg/T8wnRvNn7W">Dragonruby GTK Discord</a> #oss-zif channel.</p>

<h1 id="development">Development</h1>

<h2 id="dependencies">Dependencies</h2>

<p>For development you should install the dependencies using Bundler. Ensure you have a recent (&gt; 2.7) version of Ruby installed, and run <code class="language-plaintext highlighter-rouge">bundle install</code> to install the dependencies.</p>

<p>If EventMachine won’t install, on MacOS at least, try:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>openssl@1.1
gem <span class="nb">install </span>eventmachine <span class="nt">--</span> <span class="nt">--with-openssl-dir</span><span class="o">=</span><span class="si">$(</span>brew <span class="nt">--prefix</span> openssl@1.1<span class="si">)</span>
</code></pre></div></div>

<p>and then <code class="language-plaintext highlighter-rouge">bundle install</code> again.</p>

<h2 id="testing">Testing</h2>

<p>Tests can be found in the <code class="language-plaintext highlighter-rouge">tests</code> directory.</p>

<p>To execute the tests use the following command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./dragonruby ./path/to/dragonruby-zif <span class="nt">--test</span> tests/zif.rb<span class="sb">`</span>
</code></pre></div></div>

<h2 id="linting">Linting</h2>

<p>This project is linted with <a href="https://rubocop.org/">RuboCop</a>.</p>

<p>To execute RuboCop run</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rubocop <span class="nt">-D</span>
</code></pre></div></div>

        
      </section>

      <footer class="page__meta">
        
        


        

      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 dragonruby-zif. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
